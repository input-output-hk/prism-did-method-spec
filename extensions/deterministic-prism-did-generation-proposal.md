# Deterministic PRISM DID Generation Proposal

## Introduction

This document proposes a deterministic method for generating a PRISM Decentralized Identifier (DID) from a mnemonic phrase.
Using existing standards without requiring any modification to the [DID:PRISM method specification](https://github.com/input-output-hk/prism-did-method-spec).

The motivation for this approach is to enable the creation and restoration of PRISM DIDs.
By leveraging deterministic key derivation techniques, a DID and its corresponding keys can be reproduced from the same initial mnemonic phrase at any time, without the need to persistently store the keys or the DID itself.
By making the initial state of the DID stateless or known. Knowning that the DID  contains only the initial 'MASTER' public key generated by the mnemonic phrase. This will always correspond to the same DID specific identifier.


## Deterministic DID from a Mnemonic Code

This specification builds upon two well-established standards in hierarchical deterministic (HD) key generation:

- **[BIP-39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)** defines the generation of a binary seed from a human-readable mnemonic phrase (e.g., 12 or 24 words).
- **[BIP-44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki)** specifies a logical hierarchy for key derivation.
  - **[CIP-1852](https://cips.cardano.org/cip/CIP-1852)** extendes for use in the Cardano ecosystem.
  - **[PRISM ADR of 2023-05-16](https://hyperledger-identus.github.io/docs/adrs/decisions/2023-05-16-hierarchical-deterministic-key-generation-algorithm** proposes a hierarchical deterministic key generation algorithm for PRISM.

By applying BIP-39 to generate a seed from a mnemonic, and using a deterministic derivation path inspired by CIP-1852, we produce a single **Master Key**. This Master Key serves as the root for deterministically deriving the keys necessary to construct a PRISM DID.

This Master Key acts as the root for all subsequent key derivations used to construct a PRISM DID. Because the PRISM DID itself is computed as a hash of the canonicalized initial DID Document, the DID can be deterministically regenerated from the same Master Key and context-specific inputs.
This inicial creation event would be immediately followed by a update event with all the information a user may want to add to get to a state DID Document

Once the DID is resolved (via the standard PRISM method), the corresponding DID Document can be inspected. For each public key in the document, its associated derivation path can be reconstructed using a deterministic scheme (e.g., based on key usage and type). This allows for re-derivation of the corresponding private keys from the Master Key, enabling recovery or signing without any key material being persistently stored.

In cases where keys are missing, deprecated, or rotated, new keys can be deterministically generated by incrementing the relevant path segments (e.g., key index), ensuring consistent and verifiable updates to the DID state.

The only requirement is that the initial input — the mnemonic phrase — must be retained. All other material (master key, derived keys, DID document, DID string) can be regenerated as needed.

## Key Properties of this approach

- ✅ **Deterministic**: The same mnemonic will always produce the same set of DIDs.
- ✅ **Stateless**: No need to persist keys or DIDs — all are regenerated from the mnemonic.
  - After determining the PRISM DID, the current state can be resolved/recovered from the Cardano blockchain for convenience.
- ✅ **Compatible**: Fully compliant with the PRISM DID method spec.
  - This proposal is a subset of what the DID PRISM method supports in the initial creation event.
- ✅ **Secure**: The DID is cryptographically tied to the mnemonic-derived seed.

The remainder of this specification defines the deterministic derivation path, how to construct a DID Document from the derived keys, and how to produce the final PRISM DID identifier.

## Derivation Path Format

We use the following derivation path for deterministic DID generation:

```
m / purpose' / method' / did-index / key-usage / key-index
```

Note: The MASTER key (and also the VDR key) is always secp256k1, according to the specifications. So there is just one public key.
The public key material can be encoded as `ECKeyData` or `CompressedECKeyData`. For the sake of being deterministic we propose to only use `CompressedECKeyData` format for the first Master Key.


### Path Component Definitions

| Path Segment | Description |
|--------------|-------------|
| `purpose'`   | Set to `29` (anagram for ID in Hex 0x1D) (Note in [CIP-1852] is `1852`). |
| `method'`    | Unique constant for PRISM DID method `29` |
| `did-index`  | Unique identifier for the DID. This allows the creation of more than one identity if needed. |
| `key-usage`  | `1` = Master Key, `8` = VDR Key, etc. |
| `key-index`  | Key index within the usage scope, allowing the creation of as many keys as needed. |

We propose to follow the [PRISM's ADR decision of 2023-05-16 for Hierarchical deterministic key generation algorithm](https://hyperledger-identus.github.io/docs/adrs/decisions/2023-05-16-hierarchical-deterministic-key-generation-algorithm)

The number 29 (`0x1D`) will be used for `purpose'` and `method'`.
The `key-usage'` will be the protobuf enum field number for KeyUsage:
```proto
enum KeyUsage {
  UNKNOWN_KEY = 0;
  MASTER_KEY = 1;
  ISSUING_KEY = 2;
  KEY_AGREEMENT_KEY = 3;
  AUTHENTICATION_KEY = 4;
  REVOCATION_KEY = 5;
  CAPABILITY_INVOCATION_KEY = 6;
  CAPABILITY_DELEGATION_KEY = 7;
  VDR_KEY = 8;
}
```

### Examples / test vector

Using the following `mnemonic-phrase` (with no/empty `mnemonic-passphrase`)
```json
[
  "vacuum","only","object","oxygen","sell","engine",
  "firm","fiscal","shiver","finish","village","clock",
  "limit","unable","reject","lawn","hard","adapt",
  "plunge","between","lawsuit","stuff","educate","knock"
]
```
This will make the following seed (in Hex)`3b32a5049f2b4e3af31ec5c1ae75fada1ad2eb8be5accf56ada343ad89eeb083208e538b3b97836e3bd7048c131421bf5bea9e3a1d25812a2d831e2bab89e058`

#### Keys (from the above mnemonic seed)

All `MASTER_KEY` and `VDR_KEY` are of the type `secp256k1`:

| Key Derivation Path  | Private key (in Hex)                                               |
| -------------------- | ------------------------------------------------------------------ |
| `m/29'/29'/0'/1'/0'` | `158bf13202ccafe551b5b4e60ed516efe0fe190e5c1421c3387f0f9fef2a6111` |
| `m/29'/29'/0'/1'/1'` | `a6836a79808f82cf91a443e6040041f12799a2567039b29b72bb0a31357368d1` |
| `m/29'/29'/0'/8'/0'` | `12d9eda38cc9a8a26b3ffb5d421367977bb3adbe766e188ec54f3c713d123681` |
| `m/29'/29'/1'/1'/0'` | `7419c4c397bcc7209dadbd8a7b9a957ea9266bea605867a330b5d40073e9df30` |
| `m/29'/29'/1'/1'/1'` | `9525cb7bfbce9b34da5e730aa82d5a1779bd5a337777909059a9ee91b244d561` |
| `m/29'/29'/1'/8'/0'` | `856b8496af764af3f8b864f3dbf00be61aeee46e531f07248ff77dc58eb51160` |
| `m/29'/29'/2'/1'/0'` | `591f15d298c49611003bf7b85b7d4b4d100aa34a9680e1faf55a409f837e2f96` |
| `m/29'/29'/2'/1'/1'` | `61a9950ff1c6cb3775e2776c7772ed1bd0bd8f9ced15cffd7d633f893ef55cd8` |
| `m/29'/29'/2'/8'/0'` | `1e17ca1575b2084366441abb2c109fc0600e495e6b7097d1678645b7662d4ca6` |

Only the First Master key of the DID will be used to create a PRISM DID
- So `m/29'/29'/0'/1'/0'` will create `did:prism:35fbaf7f8a68e927feb89dc897f4edc24ca8d7510261829e4834d931e947e6ca`
- So `m/29'/29'/1'/1'/0'` will create `did:prism:c25c6ca7f4062cbdb5f770cbc88de6c679a0efd4674dbeee76d78b91cd82daac`
- So `m/29'/29'/2'/1'/0'` will create `did:prism:fe521d12e470aef305cd2e27e1b940c5492f3595452019cb2f4c9ca9835c346e`

#### First DID (from the above mnemonic seed)
- derivationPath = `m/29'/29'/0'/1'/0'`
- Private key (in Hex) = `158bf13202ccafe551b5b4e60ed516efe0fe190e5c1421c3387f0f9fef2a6111`
- Json representation of the content of the PRISM create event:
  ```json
  {
    "publicKeys" : [
      {
        "CompressedECKey" : {
          "id" : "master",
          "usage" : "MasterKeyUsage",
          "curve" : "secp256k1",
          "data" : "023f7c75c9e5fba08fea1640d6faa3f8dc0151261d2b56026d46ddcbe1fc5a5bbb"
        }
      }
    ],
    "services" : [],
    "context" : []
  }
  ```
- The PRISM create event (in Hex) = `0a066d617374657212473045022100cd3308fa4d13486687b0f3633633a6a115d45c945eec12c9e81c4e7e650149cb02206f8bd1590f4638ba3e40e50e592b97f0c4ccb303e17b17377151cc3aed21969a1a400a3e0a3c123a0a066d617374657210014a2e0a09736563703235366b311221023f7c75c9e5fba08fea1640d6faa3f8dc0151261d2b56026d46ddcbe1fc5a5bbb`
- PRISM DID = `did:prism:35fbaf7f8a68e927feb89dc897f4edc24ca8d7510261829e4834d931e947e6ca`

#### Second DID (from the above mnemonic seed)
- derivationPath = `m/29'/29'/1'/1'/0'`
- Private key (in Hex) = `7419c4c397bcc7209dadbd8a7b9a957ea9266bea605867a330b5d40073e9df30`
- Json representation of the content of the PRISM create event:
  ```json
  {
    "publicKeys" : [
      {
        "CompressedECKey" : {
          "id" : "master",
          "usage" : "MasterKeyUsage",
          "curve" : "secp256k1",
          "data" : "037f6dccdb0a8db24adb075ea4021eaab3d593cd200d9f1afebbbc58119d6585ca"
        }
      }
    ],
    "services" : [],
    "context" : []
  }
  ```
- The PRISM create event (in Hex) = `0a066d61737465721246304402200b0cfbe9f544580997601451af85351648d3c7349592bce867d97af9852c43ff022052dc3b119d20aed79a3b52adfc12d21a1acca456d317f6d31800461de9e646ed1a400a3e0a3c123a0a066d617374657210014a2e0a09736563703235366b311221037f6dccdb0a8db24adb075ea4021eaab3d593cd200d9f1afebbbc58119d6585ca`
- PRISM DID = `did:prism:c25c6ca7f4062cbdb5f770cbc88de6c679a0efd4674dbeee76d78b91cd82daac`


## DID Construction

1. Derive the MASTER_KEY using the derivation path `m/29'/29'/0'/1'/0'` from the mnemonic phrase.
2. Construct the PRISM DID using only the MASTER_KEY public key with the label/id `master`.
3. Immediately update the DID to get to the desirable state. (So the DID document contains desirable information.)
   Generate any other keys as needed using the derivation path format define above.
3. Push both the create and update events in the same PRISM BLOCK to Cardano mainnet.

## Concerns and Considerations

- Are the different DID from one mnemonic phrase all related?
  - The `did-index` segment in the derivation path determine the DID. Since all the other segments are known `m/29'/29'/did-index'/1'/0'`.
  - Unless you know the mnemonic phrase, and consequently, the seeds used to generate the MASTER keys. There is no way to relate the different dates.
  - None of the different dates would have one key in common because segment `did-index` is part of the derivation Path of any key

- PRISM allowed key routation of the MASTER key. But if all possible MASTER keys are define by mnemonic phrase. There is no way to rotate the mnemonic phrase deterministically.
  - This is a proposal on how to generate keys and PRISM DIDs in a deterministic way. I'm not part of the specification of the DID PRISM.
    So the owner can simply rotate the MASTER key to another key that is not generated by the mnemonic phrase.

- My PRISM DID was not inicial created using this proposal. So can I still use it to generate keys?
  - Yes. But any tooling created from these proposal need a way to associate a specific id to the mnemonic phrase. And there are three ways:
    - It is deterministic (e.g. by falling this proposal)
    - By add/rotate the original DID's MASTER key to the public key generated by `m/29'/29'/0'/1'/0'` of a mnemonic phrase.
      Then search all PRISM DIDs already published on Cardano, including the history of each DID. Until you find the one that add the MASTER key to the public key generated by `m/29'/29'/0'/1'/0'` of a mnemonic phrase.
    - By add/rotate the original DID's MASTER key to the public key generated by `m/29'/29'/0'/1'/0'` of a mnemonic phrase.
      Then create a new SSI/DID deterministically by following this proposal, and immediately update it to include an 'also known as' reference to the original DID’s specific identifier.
      (This is just an optimization of step two but not necessary. Since this proposed recovering method is not intended to be used often.)

- Can a hardware wallet be used?
  - Yes. Hardware wallets can be used and offer the same general advantages and disadvantages as they do for cryptocurrency wallets—namely, enhanced private key security and protection against malware.
    <br> Note: Even when using the same mnemonic phrase, the addresses generated by a hardware wallet may differ from those generated by a software wallet. This is because some hardware wallets may enforce different key derivation rules or may not fully follow the standard derivation path used by HD wallets.
    <br> As long as the same derivation algorithm and path (e.g., CIP-1852 or this proposal) are consistently used, the resulting private keys — and thus the ability to regenerate DIDs — will remain possible. 
